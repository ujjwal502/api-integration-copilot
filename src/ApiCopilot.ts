import { createCompletion } from "./llm/mistralClient";
import { TypeGenerator } from "./generators/TypeGenerator";
import { ApiAnalysis, ApiAnalyzer } from "./analyzers/ApiAnalyzer";
import { DocumentationGenerator } from "./generators/DocumentationGenerator";

export class ApiCopilot {
  private apiAnalyzer: ApiAnalyzer;
  public typeGenerator: TypeGenerator;
  private docGenerator: DocumentationGenerator;

  constructor() {
    this.apiAnalyzer = new ApiAnalyzer();
    this.typeGenerator = new TypeGenerator();
    this.docGenerator = new DocumentationGenerator();
  }

  async analyzeApiResponse(response: any): Promise<string> {
    const types = await this.typeGenerator.generateTypes(response);
    const documentation = await this.docGenerator.generateDocs(response);
    return `${types}\n\n${documentation}`;
  }

  async suggestErrorHandling(apiEndpoint: string): Promise<string> {
    const prompt = `Suggest error handling strategy for API endpoint: ${apiEndpoint}`;
    return await createCompletion(prompt);
  }

  async generateApiWrapper(apiSpec: any): Promise<string> {
    const analysis = await this.apiAnalyzer.analyze(apiSpec);
    return await this.generateBoilerplate(analysis);
  }

  private async generateBoilerplate(analysis: ApiAnalysis): Promise<string> {
    const prompt = `
      Generate a TypeScript API wrapper class based on this API analysis:
      ${JSON.stringify(analysis, null, 2)}
      
      Include:
      - Constructor with configuration
      - Methods for each endpoint
      - Error handling
      - Type definitions
      - JSDoc documentation
    `;

    const wrapperCode = await createCompletion(prompt);

    // Format and clean the response
    const cleanedCode = wrapperCode
      .replace(/```typescript/g, "")
      .replace(/```/g, "")
      .trim();

    return `
// Generated by ApiCopilot
// Based on API Analysis

${cleanedCode}
`;
  }
}
